/**
 * Checkly Public API
 * These are the docs for the newly released Checkly Public API.<br />If you have any questions, please do not hesitate to get in touch with us.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CheckResult } from '../model/checkResult';
import { ForbiddenError } from '../model/forbiddenError';
import { NotFoundError } from '../model/notFoundError';
import { PaymentRequiredError } from '../model/paymentRequiredError';
import { TooManyRequestsError } from '../model/tooManyRequestsError';
import { UnauthorizedError } from '../model/unauthorizedError';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.checklyhq.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum CheckResultsApiApiKeys {
    Bearer,
}

export class CheckResultsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: CheckResultsApiApiKeys, value: string) {
        (this.authentications as any)[CheckResultsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Lists the full, raw check results for a specific check. We keep raw results for 30 days. After 30 days they are erased. However we keep the rolled up results for an indefinite period. <br><br> You can filter by check type and result type to narrow down the list. Use the `to` and `from` parameters to specify a date range (UNIX timestamp in seconds). Depending on the check type, some fields might be null. <br><br>This endpoint will return data within a six-hours timeframe. If from and to params are set, they must be at most six hours apart.If none are set, we will consider the to param to be now and from param to be six hours earlier. <br>If only the to param is set we will set from to be six hours earlier. On the contrary, if only the from param is set we will consider the to param to be six hours later. <br><br>Rate-limiting is applied to this endpoint, you can send 5 requests / 10 seconds at most.
     * @summary Lists all check results
     * @param checkId 
     * @param xChecklyAccount Your Checkly account ID, you can find it at https://app.checklyhq.com/settings/account/general
     * @param limit Limit the number of results
     * @param page Page number
     * @param from Select documents up from this UNIX timestamp (&gt;&#x3D; date). Defaults to now - 6 hours.
     * @param to Optional. Select alerts up to this UNIX timestamp (&lt; date). Defaults to 6 hours after \&quot;from\&quot;.
     * @param location Provide a data center location, e.g. \&quot;eu-west-1\&quot; to filter by location
     * @param checkType The type of the check
     * @param hasFailures Check result has one or more failures
     */
    public async getV1CheckresultsCheckid (checkId: string, xChecklyAccount?: string, limit?: number, page?: number, from?: string, to?: string, location?: 'us-east-1' | 'us-east-2' | 'us-west-1' | 'us-west-2' | 'ca-central-1' | 'sa-east-1' | 'eu-west-1' | 'eu-central-1' | 'eu-west-2' | 'eu-west-3' | 'eu-north-1' | 'eu-south-1' | 'me-south-1' | 'ap-southeast-1' | 'ap-northeast-1' | 'ap-east-1' | 'ap-southeast-2' | 'ap-southeast-3' | 'ap-northeast-2' | 'ap-northeast-3' | 'ap-south-1' | 'af-south-1', checkType?: 'BROWSER' | 'API', hasFailures?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<CheckResult>;  }> {
        const localVarPath = this.basePath + '/v1/check-results/{checkId}'
            .replace('{' + 'checkId' + '}', encodeURIComponent(String(checkId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'checkId' is not null or undefined
        if (checkId === null || checkId === undefined) {
            throw new Error('Required parameter checkId was null or undefined when calling getV1CheckresultsCheckid.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }

        if (location !== undefined) {
            localVarQueryParameters['location'] = ObjectSerializer.serialize(location, "'us-east-1' | 'us-east-2' | 'us-west-1' | 'us-west-2' | 'ca-central-1' | 'sa-east-1' | 'eu-west-1' | 'eu-central-1' | 'eu-west-2' | 'eu-west-3' | 'eu-north-1' | 'eu-south-1' | 'me-south-1' | 'ap-southeast-1' | 'ap-northeast-1' | 'ap-east-1' | 'ap-southeast-2' | 'ap-southeast-3' | 'ap-northeast-2' | 'ap-northeast-3' | 'ap-south-1' | 'af-south-1'");
        }

        if (checkType !== undefined) {
            localVarQueryParameters['checkType'] = ObjectSerializer.serialize(checkType, "'BROWSER' | 'API'");
        }

        if (hasFailures !== undefined) {
            localVarQueryParameters['hasFailures'] = ObjectSerializer.serialize(hasFailures, "boolean");
        }

        localVarHeaderParams['x-checkly-account'] = ObjectSerializer.serialize(xChecklyAccount, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.Bearer.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.Bearer.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<CheckResult>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<CheckResult>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Show details of a specific check result.
     * @summary Retrieve a check result
     * @param checkId 
     * @param checkResultId 
     * @param xChecklyAccount Your Checkly account ID, you can find it at https://app.checklyhq.com/settings/account/general
     */
    public async getV1CheckresultsCheckidCheckresultid (checkId: string, checkResultId: string, xChecklyAccount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CheckResult;  }> {
        const localVarPath = this.basePath + '/v1/check-results/{checkId}/{checkResultId}'
            .replace('{' + 'checkId' + '}', encodeURIComponent(String(checkId)))
            .replace('{' + 'checkResultId' + '}', encodeURIComponent(String(checkResultId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'checkId' is not null or undefined
        if (checkId === null || checkId === undefined) {
            throw new Error('Required parameter checkId was null or undefined when calling getV1CheckresultsCheckidCheckresultid.');
        }

        // verify required parameter 'checkResultId' is not null or undefined
        if (checkResultId === null || checkResultId === undefined) {
            throw new Error('Required parameter checkResultId was null or undefined when calling getV1CheckresultsCheckidCheckresultid.');
        }

        localVarHeaderParams['x-checkly-account'] = ObjectSerializer.serialize(xChecklyAccount, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.Bearer.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.Bearer.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CheckResult;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CheckResult");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
